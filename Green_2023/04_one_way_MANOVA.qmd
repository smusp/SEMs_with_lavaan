---
title: "One-Way MANOVA"
highlight-style: solarized

format:
  html:
    theme: "../styles.scss"
    embed-resources: true
  gfm: default

execute:
  eval: false

format-links: false
---

```{r echo = FALSE}
## One-way MANOVA
##
## Thompson, M., Lie, Y. & Green, S. (2023). Flexible structural equation modeling
## approaches for analyzing means. In R. Hoyle (Ed.), Handbook of structural
## equation modeling (2nd ed., pp. 385-408). New York, NY: Guilford Press.
```

Thompson, M., Lie, Y. & Green, S. (2023). Flexible structural equation modeling approaches for analyzing means. In R. Hoyle (Ed.), *Handbook of structural equation modeling* (2nd ed., pp. 385-408). New York, NY: Guilford Press.


This example shows the SEM approach to Part 4: One-way MANOVA. Results are reported in Table 21.5 (p. 399).

The data are described on pages 397 and 398.


#### Load package and get the data

Load the **lavaan** package, and run `satisfactionII.r` to get the data (`satisfactionII.r` is available at the end of this post).

```{r echo = c(-4, -1)}
## Load package
library(lavaan)

## Get the data
source("satisfactionII.r")
head(df)
```

The variables used in this example are:

 - x - Coping Strategy ("a" - no strategy; "b" - discussion; "c" - exercise)
 - y1, y2, y3, y4 - Multiple dependent variables (Life-Satisfaction scores)


#### The models

The SEM path diagram for the a one-way MANOVA is shown in Fig 21.2 (p. 400), and is reproduced below. The diagram shows the "Less Constrained" model. The means are represented by the labels on the arrows connecting the "1" to the dependent variables. The means for each variable are allowed to differ across the groups. The residual variances and covariances are constrained to equality.

![](images/one_way_MANOVA.svg){fig-align="center"}

The model statements are shown below. The "More Constrained" model constrains the means to equality. The "Less Constrained" model allows the means to differ across the groups. In both cases the residual variances and covariances are constrained to equality. The variancs and covariances can be set up separately - see `vcov` below. Then, `vcov` is added back into each model. Saves a little typing.

```{r echo = c(-1)}
## The models
# Variances and covariances (for both models)
vcov <-
   "y1 ~~ c(e1, e1, e1)*y1
    y2 ~~ c(e2, e2, e2)*y2
    y3 ~~ c(e3, e3, e3)*y3
    y4 ~~ c(e4, e4, e4)*y4

    y1 ~~ c(e12, e12, e12)*y2
    y1 ~~ c(e13, e13, e13)*y3
    y1 ~~ c(e14, e14, e14)*y4
    y2 ~~ c(e23, e23, e23)*y3
    y2 ~~ c(e24, e24, e24)*y4
    y3 ~~ c(e34, e34, e34)*y4"

models <- list(
  "More Constrained" = c(
    # Means
    "y1 ~ c(a1, a1, a1)*1
     y2 ~ c(a2, a2, a2)*1
     y3 ~ c(a3, a3, a3)*1
     y4 ~ c(a4, a4, a4)*1",
	 vcov),

  "Less Constrained" =  c(
    # Means
    "y1 ~ c(a1, b1, c1)*1
     y2 ~ c(a2, b2, c2)*1
     y3 ~ c(a3, b3, c3)*1
     y4 ~ c(a4, b4, c4)*1",
	 vcov)
)
```


#### Fit the models and get the results

```{r echo = -2:-1}
## Fit the models and get the results
## Check means and chi square test in Table 21.5
## Fit the models 
fit <- lapply(models, sem, data = df, group = "x")

## Get model summaries
lapply(fit, summary)

## Contrast model fits
Reduce(anova, fit)
```

The "SEM" section of Table 21.5 shows the $\upchi$^2^ test.

Scroll through the summaries to find the "Intercepts", or extract them from the list of estimates of model parameter.

```{r echo = -1}
## Extract means from list of estimates
## Get list of estimates
estimates <- lapply(fit, lavInspect, "est"); estimates

## Extract means - in element "nu"
means <- list()
for (i in names(models)) {
   means[[i]] = estimates[[i]] |>
      sapply("[[", "nu") |>
      round(2)
   row.names(means[[i]]) = c("Y1", "Y2", "Y3", "Y4")
}
means  # Typos among "Less Constrained" means in Table 21.5)
```

Compare with the means in Table 21.5.

By way of completeness, get the error SSCP matrices. (Thompson, Lie & Green state that, "the error SSCP matrices were perfectly reproduced by multiplying the variances and covariances in the SEM output by the total sample size" p. 398).

```{r echo = -1}
## Get the error SSCP matrices by hand
# Note: In the list of estimates, co/variances are in element "theta"
E <- estimates |>
  lapply("[[", "a") |>           # Extract estimates for group "a"
  lapply("[[", "theta") |>       # Extract "theta" element
  lapply(matrix, nrow = 4) |>    # Get the full matrix
  lapply("*", 200)               # Multiply by sample size
E
```


#### Relax homogeneity of variances and covariances assumption

Towards the end of the section headed "Avoiding OLS assumptions for ANOVA/MANOVA designs using SEM" (pp. 398-401), TLG present the results for models in which the assumptions of homogeneity and normality are relaxed. That is, variances and covariances are not constrained to equality, and a robust ML method of estimation (MLM) is employed. Again, the variances and covariances are set up separately, then added back into each model. This time, there are no labels for the variances and covariances, meaning that **lavaan** will estimate each variance and covariance for each group.

```{r echo = c(-2:-1)}
## Relax homogeneity of variances and covariances assumption
## Check chi square on page 401
## Model statements
# Variances and covariances (for both models)
vcov <- 
  "y1 ~~ y1 + y2 + y3 + y4
   y2 ~~ y2 + y3 + y4
   y3 ~~ y3 + y4
   y4 ~~ y4"

models <- list(
  "Less Constrained" =  c(
    # Means
    "y1 ~ c(a1, b1, c1)*1
     y2 ~ c(a2, b2, c2)*1
     y3 ~ c(a3, b3, c3)*1
     y4 ~ c(a4, b4, c4)*1",
     vcov),

  "More Constrained" = c(
    # Means
    "y1 ~ c(a1, a1, a1)*1
     y2 ~ c(a2, a2, a2)*1
     y3 ~ c(a3, a3, a3)*1
     y4 ~ c(a4, a4, a4)*1",
	 vcov)
)

## Fit the models
fit <- lapply(models, sem, data = df, estimator = "mlm", group = "x")

## Get model summaries
lapply(fit, summary)

## Contrast model fits
Reduce(anova, fit)
```

Compare with the $\upchi$^2^ test on page 401.

<br />

```{r}
#| echo: false
#| include: false
#| eval: true
#| purl: false
input <- knitr::current_input()
output <- "R/one_way_MANOVA.r"
knitr::purl(input, output, documentation = 0, quiet = TRUE)
xfun::gsub_file(output, "^# NA", "")
xfun::gsub_file(output, "^# ", "")
```

```{r}
#| echo: true
#| code-fold: true
#| code-summary: "R code with minimal commenting"
#| file: !expr "noquote(output)"
```

```{r}
#| echo: true
#| code-fold: true
#| code-summary: "R code to get data file - `satisfactionII.r`"
#| file: "R/satisfactionII.r"
``` 